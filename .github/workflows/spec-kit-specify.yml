name: Spec Kit - Specify Feature

# Implements: Feature specification generation + Azure DevOps Description overwrite
# Deferred (Backlog): FR-004 (logging), FR-005 (failure surfacing), FR-006 (enhanced traceability),
#                     FR-007 (regeneration), FR-008 (debounce), FR-010 (performance SLO),
#                     FR-011 (assumption auto-insertion)
# See: specs/001-ado-github-spec/spec.md Backlog section

on:
  workflow_dispatch:
    inputs:
      feature_description:
        description: 'Feature description (what to build)'
        required: true
        type: string
      create_branch:
        description: 'Create feature branch automatically'
        required: false
        type: boolean
        default: true
      work_item_id:
        description: 'Azure DevOps Work Item ID (for Description overwrite)'
        required: false
        type: string

jobs:
  specify-feature:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      spec_file: ${{ steps.create_feature.outputs.spec_file }}
      branch_name: ${{ steps.create_feature.outputs.branch_name }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup Python for Spec Kit
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          echo "üì¶ Installing Python dependencies (openai for LLM scripts)..."
          pip install -q openai

      - name: Cache uv and Specify CLI
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/uv
            ~/.local/share/uv
            ~/.local/bin/specify
          key: ${{ runner.os }}-uv-specify-${{ hashFiles('**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-uv-specify-

      - name: Install uv and Specify CLI
        run: |
          if ! command -v uv &> /dev/null; then
            echo "üì¶ Installing uv package manager..."
            curl -LsSf https://astral.sh/uv/install.sh | sh
          else
            echo "‚úÖ uv already cached"
          fi
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH

          export PATH="$HOME/.cargo/bin:$PATH"
          
          if ! command -v specify &> /dev/null; then
            echo "üì¶ Installing Specify CLI..."
            uv tool install specify-cli --from git+https://github.com/github/spec-kit.git
          else
            echo "‚úÖ Specify CLI already cached"
          fi
          echo "$HOME/.local/bin" >> $GITHUB_PATH

          echo "‚úÖ Dependencies ready"

      - name: Cache GitHub Copilot CLI
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-copilot-v1
          restore-keys: |
            ${{ runner.os }}-npm-copilot-
            ${{ runner.os }}-npm-

      - name: Install GitHub Copilot CLI
        run: |
          echo "üì¶ Installing GitHub Copilot CLI..."
          npm install -g @github/copilot
          npx @github/copilot --version
          echo "‚úÖ Copilot CLI installed"

      - name: Verify Spec Kit prompts
        run: |
          echo "üîç Checking for Spec Kit prompts..."
          if [ ! -d ".github/prompts" ]; then
            echo "‚ùå ERROR: Spec Kit not initialized!"
            echo "Please run 'spec-kit-init.yml' workflow first"
            exit 1
          fi

          if [ ! -f ".github/prompts/speckit.specify.prompt.md" ]; then
            echo "‚ùå ERROR: speckit.specify.prompt.md not found!"
            exit 1
          fi

          echo "‚úÖ Spec Kit prompts found"
          ls -la .github/prompts/speckit.*.prompt.md

      - name: Step 1 - Generate Short Name with Copilot
        id: generate_name
        env:
          GITHUB_TOKEN: ${{ secrets.COPILOT_TOKEN || secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.COPILOT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          export GITHUB_TOKEN="${GITHUB_TOKEN}"
          export GH_TOKEN="${GH_TOKEN}"

          if [ -z "$GITHUB_TOKEN" ]; then
            echo "‚ùå ERROR: No authentication token found!"
            exit 1
          fi

          echo "ü§ñ Step 1: Generating short branch name..."
          echo ""
          echo "Feature: ${{ github.event.inputs.feature_description }}"
          echo ""

          # Ask Copilot directly with compact prompt
          npx @github/copilot --allow-all-tools -p "Generate a 2-4 word kebab-case branch name for: ${{ github.event.inputs.feature_description }}. Respond with ONLY the branch name." 2>&1 | tee short_name_output.txt

          # Extract the short name (first non-empty line before statistics)
          SHORT_NAME=$(head -1 short_name_output.txt | tr -d '`' | xargs)

          echo "Generated short name: $SHORT_NAME"
          echo "short_name=$SHORT_NAME" >> $GITHUB_OUTPUT

      - name: Step 2 - Run create-new-feature script
        id: create_feature
        run: |
          export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$PATH"

          SHORT_NAME="${{ steps.generate_name.outputs.short_name }}"
          FEATURE_DESC="${{ github.event.inputs.feature_description }}"

          echo "üå± Step 2: Running create-new-feature.sh script..."
          echo "Short name: $SHORT_NAME"
          echo "Description: $FEATURE_DESC"
          echo ""

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Run the script with --json flag
          cd "$GITHUB_WORKSPACE"
          .specify/scripts/bash/create-new-feature.sh --json --short-name "$SHORT_NAME" "$FEATURE_DESC" > feature_output.json

          # Parse JSON output
          cat feature_output.json
          BRANCH_NAME=$(jq -r '.BRANCH_NAME' feature_output.json)
          SPEC_FILE=$(jq -r '.SPEC_FILE' feature_output.json)
          FEATURE_DIR=$(jq -r '.FEATURE_DIR' feature_output.json)

          # Use multiline output format for long paths
          {
            echo "branch_name=$BRANCH_NAME"
            echo "spec_file<<EOF"
            echo "$SPEC_FILE"
            echo "EOF"
            echo "feature_dir=$FEATURE_DIR"
          } >> $GITHUB_OUTPUT

          echo ""
          echo "‚úÖ Feature scaffolding created:"
          echo "  Branch: $BRANCH_NAME"
          echo "  Spec file: $SPEC_FILE"
          echo "  Feature dir: $FEATURE_DIR"

      - name: Step 3-6 - Generate Specification with Copilot
        env:
          GITHUB_TOKEN: ${{ secrets.COPILOT_TOKEN || secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.COPILOT_TOKEN || secrets.GITHUB_TOKEN }}
          GH_WORKFLOW_DISPATCH_PAT: ${{ secrets.GH_WORKFLOW_DISPATCH_PAT }}
          AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
        run: |
          export GITHUB_TOKEN="${GITHUB_TOKEN}"
          export GH_TOKEN="${GH_TOKEN}"
          export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$PATH"

          SPEC_FILE="${{ steps.create_feature.outputs.spec_file }}"
          FEATURE_DESC="${{ github.event.inputs.feature_description }}"
          BRANCH_NAME="${{ steps.create_feature.outputs.branch_name }}"
          FEATURE_DIR="${{ steps.create_feature.outputs.feature_dir }}"

          # Fallback: Derive FEATURE_DIR from SPEC_FILE if null
          if [ -z "$FEATURE_DIR" ] || [ "$FEATURE_DIR" = "null" ]; then
            FEATURE_DIR="$(dirname "$SPEC_FILE")"
            echo "‚ÑπÔ∏è  FEATURE_DIR was null, derived from SPEC_FILE: $FEATURE_DIR"
          fi

          echo "üìù Step 3-6: Generating specification with Copilot..."
          echo ""

          # Save feature description to temp file to avoid special character issues
          FEATURE_DESC_FILE="$FEATURE_DIR/feature_description.txt"
          echo "$FEATURE_DESC" > "$FEATURE_DESC_FILE"
          echo "üíæ Saved feature description to: $FEATURE_DESC_FILE"
          echo ""

          # Generate spec with Copilot - using run-copilot-with-prompt.sh script
          .specify/scripts/bash/run-copilot-with-prompt.sh speckit.specify \
            FEATURE_DESC_FILE="$FEATURE_DESC_FILE" \
            BRANCH_NAME="$BRANCH_NAME" \
            SPEC_FILE="$SPEC_FILE" \
            FEATURE_DIR="$FEATURE_DIR" \
            2>&1 | tee spec_output.txt

          # Copilot with --allow-all-tools may create files directly
          # Search entire specs directory for newly created spec.md files first, then any .md
          SPEC_DIR=$(dirname "$SPEC_FILE")
          CREATED_SPEC=$(find specs -name "spec.md" -type f -newer "$SPEC_FILE" ! -path "$SPEC_FILE" 2>/dev/null | head -1)
          
          # If no spec.md found, look for any other .md file (fallback)
          if [ -z "$CREATED_SPEC" ]; then
            CREATED_SPEC=$(find specs -name "*.md" -type f -newer "$SPEC_FILE" ! -path "$SPEC_FILE" 2>/dev/null | head -1)
          fi

          if [ -n "$CREATED_SPEC" ] && [ -f "$CREATED_SPEC" ]; then
            echo "‚úÖ Copilot created file: $CREATED_SPEC"
            CREATED_DIR=$(dirname "$CREATED_SPEC")
            echo "üìã Moving spec to: $SPEC_FILE"
            cat "$CREATED_SPEC" > "$SPEC_FILE"
            
            # Copy checklists directory if it exists
            if [ -d "$CREATED_DIR/checklists" ]; then
              echo "üìã Copying checklists directory"
              cp -r "$CREATED_DIR/checklists" "$SPEC_DIR/"
            fi
            
            echo "üßπ Removing Copilot-created directory: $CREATED_DIR"
            rm -rf "$CREATED_DIR"
          else
            echo "‚ö†Ô∏è Copilot didn't create file directly, extracting from output..."
            # Extract markdown from output
            if grep -q "<< 'EOF'" spec_output.txt; then
              sed -n "/cat > .* << 'EOF'/,/^EOF$/p" spec_output.txt | sed '1d;$d' > "$SPEC_FILE"
            else
              sed -n '/^# /,${/Total usage/q;p}' spec_output.txt > "$SPEC_FILE"
            fi
          fi

          # Check if Copilot asked clarification questions instead of generating spec
          # Use LLM to detect questions (robust to format variations)
          echo "ü§ñ Using LLM to detect if Copilot output contains clarification questions..."
          
          # Export AZURE_OPENAI_API_KEY to make it available in embedded Python script
          export AZURE_OPENAI_API_KEY="${AZURE_OPENAI_API_KEY}"
          
          # Try LLM detection, but fallback to simple pattern matching if it fails (e.g., firewall blocking)
          if ! .github/scripts/detect-questions-llm.sh > question_detection.json 2>&1; then
            echo "‚ö†Ô∏è  LLM detection failed (may be due to firewall/network restrictions)"
            echo "Detection output:"
            cat question_detection.json || echo "(no output file)"
            echo ""
            echo "üîÑ Falling back to simple pattern-based detection..."
            
            # Fallback: Simple pattern matching for common question patterns
            if grep -qiE "(what|how|which|when|where|why|can you|do you|is there|are there|would you|could you)" spec_output.txt && \
               grep -qiE "(\?|question|clarify|clarification|need more|more information|please specify)" spec_output.txt; then
              echo '{"has_questions": true, "reason": "Fallback: Detected question patterns in Copilot output"}' > question_detection.json
            else
              echo '{"has_questions": false, "reason": "Fallback: No question patterns detected"}' > question_detection.json
            fi
          fi
          
          echo "‚úÖ Question detection completed"
          echo "Detection result:"
          cat question_detection.json
          
          HAS_QUESTIONS=$(python3 -c "import json; print(json.load(open('question_detection.json'))['has_questions'])")
          DETECTION_REASON=$(python3 -c "import json; print(json.load(open('question_detection.json'))['reason'])")
          
          if [ "$HAS_QUESTIONS" = "True" ]; then
            echo "‚ÑπÔ∏è  Copilot asked clarification questions: $DETECTION_REASON"
            echo "üìù Saving questions to spec file with markers..."
            
            # Save entire Copilot output to spec file with clarification header
            {
              echo "# Feature Specification: ${BRANCH_NAME}"
              echo ""
              echo "This feature requires clarification before implementation."
              echo ""
              echo "[NEEDS CLARIFICATION: Questions from Copilot]"
              echo ""
              cat spec_output.txt | sed '/^Total usage/,$d'
            } > "$SPEC_FILE"
            
            echo "‚úÖ Clarification questions saved to: $SPEC_FILE"
          else
            # Normal spec generation path - validate spec file
            if [ ! -f "$SPEC_FILE" ]; then
              echo "‚ùå ERROR: Spec file was not created: $SPEC_FILE"
              echo "Copilot output:"
              cat spec_output.txt
              exit 1
            fi

            SPEC_SIZE=$(wc -c < "$SPEC_FILE")
            if [ "$SPEC_SIZE" -lt 100 ]; then
              echo "‚ùå ERROR: Spec file is too small ($SPEC_SIZE bytes), generation likely failed"
              echo "Spec file content:"
              cat "$SPEC_FILE"
              echo ""
              echo "Copilot output:"
              cat spec_output.txt
              exit 1
            fi

            if ! grep -q "^# " "$SPEC_FILE"; then
              echo "‚ùå ERROR: Spec file doesn't contain markdown headers"
              echo "Spec file content:"
              cat "$SPEC_FILE"
              exit 1
            fi

            echo ""
            echo "‚úÖ Specification saved to: $SPEC_FILE"
            echo ""
            echo "Preview (first 30 lines):"
            head -30 "$SPEC_FILE"
          fi

      # T004-T006: Foundational - Marker Detection
      - name: Detect Clarification Markers
        id: detect_markers
        run: |
          SPEC_FILE="${{ steps.create_feature.outputs.spec_file }}"
          
          if grep -q '\[NEEDS CLARIFICATION:' "$SPEC_FILE"; then
            echo "markers_found=true" >> $GITHUB_OUTPUT
            MARKER_COUNT=$(grep -c '\[NEEDS CLARIFICATION:' "$SPEC_FILE" || echo "0")
            echo "marker_count=$MARKER_COUNT" >> $GITHUB_OUTPUT
            echo "‚úÖ Found $MARKER_COUNT clarification markers"
          else
            echo "markers_found=false" >> $GITHUB_OUTPUT
            echo "marker_count=0" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No clarification markers found - clear requirements"
          fi

      # T007-T010: User Story 1 - Preserve markers (already preserved by default, add logging)
      # T018-T019: User Story 2 - Extract Clarifications (using LLM for robust parsing)
      - name: Extract Clarifications
        if: steps.detect_markers.outputs.markers_found == 'true'
        env:
          GH_WORKFLOW_DISPATCH_PAT: ${{ secrets.GH_WORKFLOW_DISPATCH_PAT }}
          GITHUB_TOKEN: ${{ secrets.COPILOT_TOKEN || secrets.GITHUB_TOKEN }}
          AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
        run: |
          export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$PATH"
          
          SPEC_FILE="${{ steps.create_feature.outputs.spec_file }}"
          FEATURE_DIR="${{ steps.create_feature.outputs.feature_dir }}"
          BRANCH_NAME="${{ steps.create_feature.outputs.branch_name }}"
          
          # Fallback: Derive FEATURE_DIR from SPEC_FILE if null
          if [ -z "$FEATURE_DIR" ] || [ "$FEATURE_DIR" = "null" ]; then
            FEATURE_DIR="$(dirname "$SPEC_FILE")"
            echo "‚ÑπÔ∏è  FEATURE_DIR was null, derived from SPEC_FILE: $FEATURE_DIR"
          fi
          
          echo "üìù Extracting clarification questions using LLM..."
          python3 .github/scripts/extract-clarifications-llm.py \
            --spec-file "$SPEC_FILE" \
            --output "$FEATURE_DIR/clarifications.md" \
            --feature-name "$BRANCH_NAME"

      # T031-T032: User Story 3 - Create ADO Issues for Clarifications
      - name: Create ADO Issues for Clarifications
        if: steps.detect_markers.outputs.markers_found == 'true' && github.event.inputs.work_item_id != ''
        env:
          ADO_WORK_ITEM_PAT: ${{ secrets.ADO_WORKITEM_RW_PAT }}
          ADO_ORG_URL: https://dev.azure.com/${{ vars.ADO_ORG || 'your-org' }}
          ADO_PROJECT: ${{ vars.ADO_PROJECT || 'your-project' }}
          FEATURE_ID: ${{ github.event.inputs.work_item_id }}
          BRANCH_NAME: ${{ steps.create_feature.outputs.branch_name }}
        run: |
          SPEC_FILE="${{ steps.create_feature.outputs.spec_file }}"
          FEATURE_DIR="${{ steps.create_feature.outputs.feature_dir }}"
          
          # Fallback: Derive FEATURE_DIR from SPEC_FILE if null
          if [ -z "$FEATURE_DIR" ] || [ "$FEATURE_DIR" = "null" ]; then
            FEATURE_DIR="$(dirname "$SPEC_FILE")"
            echo "‚ÑπÔ∏è  FEATURE_DIR was null, derived from SPEC_FILE: $FEATURE_DIR"
          fi
          
          CLARIFICATIONS_FILE="$FEATURE_DIR/clarifications.md"
          
          if [ ! -f "$CLARIFICATIONS_FILE" ]; then
            echo "‚ö†Ô∏è Clarifications file not found, skipping Issue creation"
            exit 0
          fi
          
          # Install Python dependencies for ado_client.py
          echo "üì¶ Installing Python dependencies..."
          pip install -q requests
          
          echo "üé´ Creating ADO Issues for clarification questions..."
          .github/scripts/create-ado-issues.sh \
            --clarifications-file "$CLARIFICATIONS_FILE" \
            --feature-id "$FEATURE_ID" \
            --branch "$BRANCH_NAME" \
            --org-url "$ADO_ORG_URL" \
            --project "$ADO_PROJECT"

      - name: Step 7 - Commit and Push Specification
        if: github.event.inputs.create_branch == 'true'
        run: |
          BRANCH_NAME="${{ steps.create_feature.outputs.branch_name }}"
          SPEC_FILE="${{ steps.create_feature.outputs.spec_file }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "üì§ Step 7: Committing and pushing specification..."
          echo "Branch: $BRANCH_NAME"
          echo "Spec file: $SPEC_FILE"
          echo ""

          # Ensure we're on the correct branch (Copilot may have switched branches)
          CURRENT_BRANCH=$(git branch --show-current)
          if [ "$CURRENT_BRANCH" != "$BRANCH_NAME" ]; then
            echo "‚ö†Ô∏è  Currently on branch '$CURRENT_BRANCH', switching to '$BRANCH_NAME'"
            git checkout "$BRANCH_NAME"
          fi

          # Add all generated files
          git add -A

          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è No changes to commit"
          else
            echo "üíæ Committing specification..."
            git commit -m "feat: add feature specification" \
              -m "Feature: ${{ github.event.inputs.feature_description }}" \
              -m "Generated by /speckit.specify workflow" \
              -m "Spec file: $SPEC_FILE"

            echo "üì§ Pushing to branch: $BRANCH_NAME"
            git push -f origin "$BRANCH_NAME"

            echo "‚úÖ Specification committed and pushed to $BRANCH_NAME"
          fi

      # Get GitHub Connection ID from Azure DevOps API
      - name: Get GitHub Connection ID
        if: github.event.inputs.work_item_id != '' && github.event.inputs.create_branch == 'true'
        id: get_connection_id
        shell: bash
        env:
          ADO_WORKITEM_RW_PAT: ${{ secrets.ADO_WORKITEM_RW_PAT }}
          ADO_ORG: ${{ vars.ADO_ORG || 'your-org' }}
          ADO_PROJECT: ${{ vars.ADO_PROJECT || 'your-project' }}
          GITHUB_REPO: ${{ github.repository }}
        run: |
          set +e  # Disable exit on error, handle errors manually
          
          echo "üîç Querying Azure DevOps API for GitHub connection ID..."
          
          if [ -z "$ADO_WORKITEM_RW_PAT" ]; then
            echo "‚ö†Ô∏è ADO_WORKITEM_RW_PAT not set; skipping connection ID lookup"
            echo "connection_id=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ "$ADO_ORG" = "your-org" ] || [ "$ADO_PROJECT" = "your-project" ]; then
            echo "‚ö†Ô∏è ADO_ORG or ADO_PROJECT not configured; skipping connection ID lookup"
            echo "connection_id=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Try Boards External Connections API first (for Azure Boards GitHub integration)
          ENDPOINT="https://dev.azure.com/${ADO_ORG}/${ADO_PROJECT}/_apis/work/boards/externalconnections?api-version=7.0-preview.1"
          
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET \
            --http1.1 \
            --max-time 30 \
            --connect-timeout 10 \
            -H "Authorization: Basic $(echo -n ":${ADO_WORKITEM_RW_PAT}" | base64 | tr -d '\n')" \
            "$ENDPOINT" 2>&1)
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" = "200" ]; then
            # Extract connection ID from response
            # Look for GitHub connections matching the repository
            CONNECTION_ID=$(echo "$BODY" | jq -r --arg repo "$GITHUB_REPO" '.value[]? | select(.type == "GitHub" and (.repositoryName // .name // "") | contains($repo)) | .id' | head -1)
            
            if [ -n "$CONNECTION_ID" ] && [ "$CONNECTION_ID" != "null" ]; then
              echo "‚úÖ Found GitHub connection ID: $CONNECTION_ID"
              echo "connection_id=$CONNECTION_ID" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # If no match found, try to get the first GitHub connection
            CONNECTION_ID=$(echo "$BODY" | jq -r '.value[]? | select(.type == "GitHub") | .id' | head -1)
            
            if [ -n "$CONNECTION_ID" ] && [ "$CONNECTION_ID" != "null" ]; then
              echo "‚úÖ Found GitHub connection ID (first available): $CONNECTION_ID"
              echo "connection_id=$CONNECTION_ID" >> $GITHUB_OUTPUT
              exit 0
            fi
          else
            echo "‚ö†Ô∏è  Boards External Connections API returned HTTP $HTTP_CODE, trying Service Endpoints API..."
          fi
          
          # Fallback: Try Service Endpoints API
          ENDPOINT="https://dev.azure.com/${ADO_ORG}/${ADO_PROJECT}/_apis/serviceendpoint/endpoints?api-version=6.0-preview.4&type=github"
          
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET \
            --http1.1 \
            --max-time 30 \
            --connect-timeout 10 \
            -H "Authorization: Basic $(echo -n ":${ADO_WORKITEM_RW_PAT}" | base64 | tr -d '\n')" \
            "$ENDPOINT" 2>&1)
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" = "200" ]; then
            # Extract first GitHub service endpoint ID
            CONNECTION_ID=$(echo "$BODY" | jq -r '.value[0].id // empty' | head -1)
            
            if [ -n "$CONNECTION_ID" ] && [ "$CONNECTION_ID" != "null" ]; then
              echo "‚úÖ Found GitHub service endpoint ID: $CONNECTION_ID"
              echo "connection_id=$CONNECTION_ID" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "‚ö†Ô∏è  Could not find GitHub connection ID (HTTP $HTTP_CODE)"
          echo "Will fallback to Hyperlink method for branch linking"
          echo "connection_id=" >> $GITHUB_OUTPUT

      # Link GitHub Branch to ADO Work Item (Development tab)
      - name: Link GitHub Branch to ADO Work Item
        if: github.event.inputs.work_item_id != '' && github.event.inputs.create_branch == 'true'
        shell: bash
        env:
          ADO_WORKITEM_RW_PAT: ${{ secrets.ADO_WORKITEM_RW_PAT }}
          ADO_ORG: ${{ vars.ADO_ORG || 'your-org' }}
          ADO_PROJECT: ${{ vars.ADO_PROJECT || 'your-project' }}
          GITHUB_CONNECTION_ID: ${{ steps.get_connection_id.outputs.connection_id }}
          GITHUB_REPO_ID: ${{ github.repository_id }}
        run: |
          set +e  # Disable exit on error, handle errors manually
          
          WORK_ITEM_ID="${{ github.event.inputs.work_item_id }}"
          BRANCH_NAME="${{ steps.create_feature.outputs.branch_name }}"
          GITHUB_REPO="${{ github.repository }}"
          
          echo "=== ADO Branch Link Debug Info ==="
          echo "WORK_ITEM_ID: $WORK_ITEM_ID"
          echo "BRANCH_NAME: $BRANCH_NAME"
          echo "GITHUB_REPO: $GITHUB_REPO"
          echo "GITHUB_REPO_ID: $GITHUB_REPO_ID"
          echo "GITHUB_CONNECTION_ID: $GITHUB_CONNECTION_ID"
          echo "ADO_ORG: $ADO_ORG"
          echo "ADO_PROJECT: $ADO_PROJECT"
          echo "ADO_WORKITEM_RW_PAT length: ${#ADO_WORKITEM_RW_PAT}"
          echo ""
          
          if [ -z "$ADO_WORKITEM_RW_PAT" ]; then
            echo "‚ö†Ô∏è ADO_WORKITEM_RW_PAT not set; skipping branch link"
            exit 0
          fi
          
          if [ "$ADO_ORG" = "your-org" ] || [ "$ADO_PROJECT" = "your-project" ]; then
            echo "‚ùå ERROR: ADO_ORG or ADO_PROJECT not configured!"
            echo "Please set GitHub repository variables:"
            echo "  - ADO_ORG: Your Azure DevOps organization name"
            echo "  - ADO_PROJECT: Your Azure DevOps project name"
            exit 1
          fi
          
          if [ -z "$BRANCH_NAME" ]; then
            echo "‚ùå ERROR: Branch name is empty"
            exit 1
          fi
          
          # Check if work item already has a GitHub branch link
          echo "üîç Checking if work item already has a GitHub branch link..."
          GET_ENDPOINT="https://dev.azure.com/${ADO_ORG}/${ADO_PROJECT}/_apis/wit/workitems/${WORK_ITEM_ID}?api-version=7.0&\$expand=relations"
          
          GET_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET \
            --http1.1 \
            --max-time 30 \
            --connect-timeout 10 \
            -H "Authorization: Basic $(echo -n ":${ADO_WORKITEM_RW_PAT}" | base64 | tr -d '\n')" \
            "$GET_ENDPOINT" 2>&1)
          
          GET_HTTP_CODE=$(echo "$GET_RESPONSE" | tail -1)
          GET_BODY=$(echo "$GET_RESPONSE" | sed '$d')
          
          if [ "$GET_HTTP_CODE" = "200" ]; then
            # Check for existing GitHub branch links
            # Look for ArtifactLink relations with GitHub branch URLs or vstfs:///GitHub/Ref patterns
            HAS_BRANCH_LINK=$(echo "$GET_BODY" | jq -r '.relations[]? | select(.rel == "ArtifactLink" or .rel == "Hyperlink") | .url' 2>/dev/null | grep -iE "(github.*tree|vstfs:///GitHub/Ref)" || echo "")
            
            if [ -n "$HAS_BRANCH_LINK" ]; then
              echo "‚úÖ Work item already has a GitHub branch link:"
              echo "$HAS_BRANCH_LINK" | head -1
              echo "‚è≠Ô∏è  Skipping branch link creation"
              exit 0
            else
              echo "‚ÑπÔ∏è  No existing GitHub branch link found, proceeding to create one"
            fi
          else
            echo "‚ö†Ô∏è  Could not fetch work item to check existing links (HTTP $GET_HTTP_CODE)"
            echo "Proceeding with branch link creation..."
          fi
          
          # Use ArtifactLink if GitHub Connection ID is available, otherwise fallback to Hyperlink
          if [ -n "$GITHUB_CONNECTION_ID" ] && [ -n "$GITHUB_REPO_ID" ]; then
            echo "üîó Creating Development tab branch link using ArtifactLink..."
            
            # URL-encode the branch name (replace / with %2F)
            ENCODED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/\//%2F/g')
            
            # Construct the artifact URL for GitHub Branch (Development tab)
            ARTIFACT_URL="vstfs:///GitHub/Ref/${GITHUB_CONNECTION_ID}%2F${GITHUB_REPO_ID}%2Frefs%2Fheads%2F${ENCODED_BRANCH}"
            
            PAYLOAD=$(cat <<EOF
          [
            {
              "op": "add",
              "path": "/relations/-",
              "value": {
                "rel": "ArtifactLink",
                "url": "$ARTIFACT_URL",
                "attributes": {
                  "name": "Branch"
                }
              }
            }
          ]
          EOF
            )
          else
            echo "‚ö†Ô∏è  GITHUB_CONNECTION_ID or GITHUB_REPO_ID not set; using Hyperlink fallback"
            echo "Note: Hyperlink will appear in Links tab, not Development tab"
            echo "To enable Development tab linking, set ADO_GITHUB_CONNECTION_ID repository variable"
            
            # Fallback to Hyperlink
            BRANCH_URL="https://github.com/${GITHUB_REPO}/tree/${BRANCH_NAME}"
            PAYLOAD=$(cat <<EOF
          [
            {
              "op": "add",
              "path": "/relations/-",
              "value": {
                "rel": "Hyperlink",
                "url": "$BRANCH_URL",
                "attributes": {
                  "comment": "GitHub Branch: $BRANCH_NAME"
                }
              }
            }
          ]
          EOF
            )
          fi
          
          echo "üîó Linking GitHub branch to ADO Work Item #$WORK_ITEM_ID..."
          
          # PATCH with retry (exponential backoff)
          ENDPOINT="https://dev.azure.com/${ADO_ORG}/${ADO_PROJECT}/_apis/wit/workitems/${WORK_ITEM_ID}?api-version=7.0"
          
          for ATTEMPT in 1 2 3; do
            echo ""
            echo "=== Attempt $ATTEMPT/3 ==="
            echo "Endpoint: $ENDPOINT"
            echo "Payload size: ${#PAYLOAD} chars"
            
            RESPONSE=$(curl -v -s -w "\n%{http_code}" -X PATCH \
              --http1.1 \
              --max-time 30 \
              --connect-timeout 10 \
              -H "Content-Type: application/json-patch+json" \
              -H "Authorization: Basic $(echo -n ":${ADO_WORKITEM_RW_PAT}" | base64 | tr -d '\n')" \
              -d "$PAYLOAD" \
              "$ENDPOINT" 2>&1)
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            echo "HTTP Status: $HTTP_CODE"
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "204" ]; then
              echo "‚úÖ GitHub branch linked successfully (HTTP $HTTP_CODE)"
              if [ -n "$GITHUB_CONNECTION_ID" ]; then
                echo "Branch '$BRANCH_NAME' is now linked to Work Item #$WORK_ITEM_ID in the Development tab"
              else
                echo "Branch '$BRANCH_NAME' is now linked to Work Item #$WORK_ITEM_ID (Hyperlink in Links tab)"
              fi
              exit 0
            elif [ "$HTTP_CODE" = "401" ]; then
              echo "‚ùå Authentication failed (HTTP 401)"
              echo "Possible causes:"
              echo "  - Invalid or expired ADO_WORKITEM_RW_PAT"
              echo "  - PAT doesn't have 'Work Items: Read & Write' scope"
              echo "Response: $BODY"
              exit 1
            elif [ "$HTTP_CODE" = "403" ]; then
              echo "‚ùå Authorization failed (HTTP 403)"
              echo "Possible causes:"
              echo "  - PAT doesn't have permission to update work items"
              echo "  - Work item is in a protected area"
              echo "Response: $BODY"
              exit 1
            elif [ "$HTTP_CODE" = "404" ]; then
              echo "‚ùå Work item not found (HTTP 404)"
              echo "Possible causes:"
              echo "  - Work item ID $WORK_ITEM_ID doesn't exist"
              echo "  - Wrong ADO_ORG or ADO_PROJECT"
              echo "Response: $BODY"
              exit 1
            elif [[ "$HTTP_CODE" =~ ^4 ]]; then
              echo "‚ùå Client error (HTTP $HTTP_CODE); not retrying"
              echo "Response body:"
              echo "$BODY" | head -n 50
              exit 1
            else
              echo "‚ö†Ô∏è Server error (HTTP $HTTP_CODE); retrying after backoff..."
              echo "Response: $BODY" | head -n 20
              [ $ATTEMPT -lt 3 ] && sleep $((2 ** ATTEMPT))
            fi
          done
          
          echo ""
          echo "‚ùå Failed to link branch after 3 attempts"
          exit 1

      # ADO Description Overwrite (T007, T008, T009)
      # Contract reference: specs/001-ado-github-spec/contracts/README.md
      # Implements JSON Patch REPLACE operation with exponential backoff retry
      # Skip if clarification markers found - no spec generated yet, only questions
      - name: Overwrite ADO Work Item Description
        if: github.event.inputs.work_item_id != '' && steps.detect_markers.outputs.markers_found != 'true'
        shell: bash
        env:
          ADO_WORKITEM_RW_PAT: ${{ secrets.ADO_WORKITEM_RW_PAT }}
          ADO_ORG: ${{ vars.ADO_ORG || 'your-org' }}
          ADO_PROJECT: ${{ vars.ADO_PROJECT || 'your-project' }}
        run: |
          set +e  # Disable exit on error, handle errors manually
          
          WORK_ITEM_ID="${{ github.event.inputs.work_item_id }}"
          SPEC_FILE="${{ steps.create_feature.outputs.spec_file }}"

          echo "=== ADO Description Update Debug Info ==="
          echo "WORK_ITEM_ID: $WORK_ITEM_ID"
          echo "SPEC_FILE: $SPEC_FILE"
          echo "ADO_ORG: $ADO_ORG"
          echo "ADO_PROJECT: $ADO_PROJECT"
          echo "ADO_WORKITEM_RW_PAT length: ${#ADO_WORKITEM_RW_PAT}"
          echo ""

          if [ -z "$ADO_WORKITEM_RW_PAT" ]; then
            echo "‚ö†Ô∏è ADO_WORKITEM_RW_PAT not set; skipping Description overwrite"
            exit 0
          fi

          if [ "$ADO_ORG" = "your-org" ] || [ "$ADO_PROJECT" = "your-project" ]; then
            echo "‚ùå ERROR: ADO_ORG or ADO_PROJECT not configured!"
            echo "Please set GitHub repository variables:"
            echo "  - ADO_ORG: Your Azure DevOps organization name"
            echo "  - ADO_PROJECT: Your Azure DevOps project name"
            exit 1
          fi

          echo "üîÑ Overwriting ADO Work Item #$WORK_ITEM_ID Description with generated spec..."

          # Check if spec file exists
          if [ ! -f "$SPEC_FILE" ]; then
            echo "‚ùå Spec file not found: $SPEC_FILE"
            exit 1
          fi

          # Read spec content and validate it's not empty
          SPEC_CONTENT=$(<"$SPEC_FILE")
          FILE_SIZE=$(wc -c < "$SPEC_FILE")
          echo "üìÑ Spec file size: $FILE_SIZE bytes"
          
          # Validate spec has meaningful content (at least 100 bytes and contains markdown header)
          if [ "$FILE_SIZE" -lt 100 ]; then
            echo "‚ùå Spec file too small ($FILE_SIZE bytes); likely empty or generation failed"
            exit 1
          fi
          
          if ! grep -q "^# " "$SPEC_FILE"; then
            echo "‚ùå Spec file doesn't contain markdown headers; likely invalid"
            exit 1
          fi
          
          SPEC_JSON=$(jq -Rs . <<< "$SPEC_CONTENT")
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to JSON-encode spec content"
            exit 1
          fi

          # Construct JSON Patch payload
          PAYLOAD=$(cat <<EOF
          [
            {
              "op": "replace",
              "path": "/fields/System.Description",
              "value": $SPEC_JSON
            }
          ]
          EOF
          )

          # PATCH with retry (x2 exponential backoff)
          ENDPOINT="https://dev.azure.com/${ADO_ORG}/${ADO_PROJECT}/_apis/wit/workitems/${WORK_ITEM_ID}?api-version=7.0"
          
          for ATTEMPT in 1 2 3; do
            echo ""
            echo "=== Attempt $ATTEMPT/3 ==="
            echo "Endpoint: $ENDPOINT"
            echo "Payload size: ${#PAYLOAD} chars"
            
            RESPONSE=$(curl -v -s -w "\n%{http_code}" -X PATCH \
              --http1.1 \
              --max-time 30 \
              --connect-timeout 10 \
              -H "Content-Type: application/json-patch+json" \
              -H "Authorization: Basic $(echo -n ":${ADO_WORKITEM_RW_PAT}" | base64 | tr -d '\n')" \
              -d "$PAYLOAD" \
              "$ENDPOINT" 2>&1)
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            echo "HTTP Status: $HTTP_CODE"
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "204" ]; then
              echo "‚úÖ ADO Description overwritten successfully (HTTP $HTTP_CODE)"
              exit 0
            elif [ "$HTTP_CODE" = "401" ]; then
              echo "‚ùå Authentication failed (HTTP 401)"
              echo "Possible causes:"
              echo "  - Invalid or expired ADO_WORKITEM_RW_PAT"
              echo "  - PAT doesn't have 'Work Items: Read & Write' scope"
              echo "Response: $BODY"
              exit 1
            elif [ "$HTTP_CODE" = "403" ]; then
              echo "‚ùå Authorization failed (HTTP 403)"
              echo "Possible causes:"
              echo "  - PAT doesn't have permission to update work items"
              echo "  - Work item is in a protected area"
              echo "Response: $BODY"
              exit 1
            elif [ "$HTTP_CODE" = "404" ]; then
              echo "‚ùå Work item not found (HTTP 404)"
              echo "Possible causes:"
              echo "  - Work item ID $WORK_ITEM_ID doesn't exist"
              echo "  - Wrong ADO_ORG or ADO_PROJECT"
              echo "Response: $BODY"
              exit 1
            elif [[ "$HTTP_CODE" =~ ^4 ]]; then
              echo "‚ùå Client error (HTTP $HTTP_CODE); not retrying"
              echo "Response body:"
              echo "$BODY" | head -n 50
              exit 1
            else
              echo "‚ö†Ô∏è Server error (HTTP $HTTP_CODE); retrying after backoff..."
              echo "Response: $BODY" | head -n 20
              [ $ATTEMPT -lt 3 ] && sleep $((2 ** ATTEMPT))
            fi
          done
          
          echo ""
          echo "‚ùå Failed after 3 attempts"
          exit 1

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: spec-kit-output
          path: |
            short_name_output.txt
            feature_output.json
            spec_prompt.txt
            spec_output.txt
            ${{ steps.create_feature.outputs.feature_dir }}
          retention-days: 30

      - name: Summary
        if: always()
        run: |
          BRANCH_NAME="${{ steps.create_feature.outputs.branch_name }}"
          SPEC_FILE="${{ steps.create_feature.outputs.spec_file }}"
          FEATURE_DIR="${{ steps.create_feature.outputs.feature_dir }}"
          SHORT_NAME="${{ steps.generate_name.outputs.short_name }}"
          MARKERS_FOUND="${{ steps.detect_markers.outputs.markers_found }}"
          MARKER_COUNT="${{ steps.detect_markers.outputs.marker_count }}"

          echo "## üìã Spec Kit - Specify Feature" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Feature:** ${{ github.event.inputs.feature_description }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Short Name:** \`$SHORT_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Spec File:** \`$SPEC_FILE\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Feature Directory:** \`$FEATURE_DIR\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Clarification Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$MARKERS_FOUND" = "true" ]; then
            echo "- **Markers Found:** ‚úÖ Yes ($MARKER_COUNT markers)" >> $GITHUB_STEP_SUMMARY
            if [ -f "$FEATURE_DIR/clarifications.md" ]; then
              echo "- **Clarifications File:** ‚úÖ Created at \`$FEATURE_DIR/clarifications.md\`" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **Clarifications File:** ‚ùå Not created" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -n "${{ github.event.inputs.work_item_id }}" ]; then
              echo "- **ADO Issues:** ‚úÖ Created for Feature #${{ github.event.inputs.work_item_id }}" >> $GITHUB_STEP_SUMMARY
            else
              echo "- **ADO Issues:** ‚è≠Ô∏è Skipped (no work_item_id provided)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "- **Markers Found:** ‚úÖ No - Clear requirements, no clarifications needed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Completed Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. ‚úÖ Generated short branch name using Copilot" >> $GITHUB_STEP_SUMMARY
          echo "2. ‚úÖ Created feature scaffolding with \`create-new-feature.sh\`" >> $GITHUB_STEP_SUMMARY
          echo "3. ‚úÖ Generated specification using Copilot + spec template" >> $GITHUB_STEP_SUMMARY
          echo "4. ‚úÖ Committed and pushed to feature branch" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìñ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the generated specification in the feature branch" >> $GITHUB_STEP_SUMMARY
          echo "2. Run \`/speckit.clarify\` if there are [NEEDS CLARIFICATION] markers" >> $GITHUB_STEP_SUMMARY
          echo "3. Run \`/speckit.plan\` to create technical implementation plan" >> $GITHUB_STEP_SUMMARY
          echo "4. Run \`/speckit.tasks\` to generate actionable task lists" >> $GITHUB_STEP_SUMMARY
          echo "5. Run \`/speckit.implement\` to execute all tasks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- [View Branch](https://github.com/${{ github.repository }}/tree/$BRANCH_NAME)" >> $GITHUB_STEP_SUMMARY
          echo "- [View Spec](https://github.com/${{ github.repository }}/blob/$BRANCH_NAME/$SPEC_FILE)" >> $GITHUB_STEP_SUMMARY
          echo "- [Spec Kit Documentation](https://github.github.io/spec-kit/)" >> $GITHUB_STEP_SUMMARY
